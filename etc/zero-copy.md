# Zero-Copy

### Zero Copy란?
Zero-copy는 데이터를 한 위치에서 다른 위치로 복사하지 않고 메모리 상의 데이터를 공유하여 처리 성능을 향상시키는 기술입니다. 
일반적으로 데이터를 복사하려면 소스 메모리에서 데이터를 읽고 대상 메모리로 데이터를 쓰는 과정이 필요합니다. 
그러나 Zero-copy 기술은 이러한 복사 작업을 피하고 메모리의 데이터를 직접 공유함으로써 성능을 최적화합니다.

### Zero Copy의 특징

Zero-copy는 대량의 데이터를 처리하는 경우에 특히 유용합니다. 
데이터를 복사하는 작업은 CPU 및 메모리 대역폭을 사용하므로 이러한 복사 작업을 최소화하면 전체적인 시스템 성능을 향상시킬 수 있습니다. 
또한, 복사 작업을 제거하면 메모리 사용량도 줄어들어 메모리 관리의 효율성도 향상될 수 있습니다.

### 동작방식

- 데이터를 읽을 때: 일반적으로 디스크에서 데이터를 읽는 작업은 운영 체제의 파일 시스템에 의해 처리됩니다. Zero-copy를 사용하면 읽은 데이터를 운영 체제의 파일 시스템 버퍼(cache)에 저장할 수 있습니다. 그러면 애플리케이션은 이 버퍼를 직접 참조하여 데이터를 처리할 수 있습니다.
- 데이터를 쓸 때: 데이터를 쓸 때도 마찬가지로, 애플리케이션은 데이터를 운영 체제의 버퍼에 기록합니다. 운영 체제는 이 버퍼를 이용해 실제 디스크로의 쓰기 작업을 관리합니다. 이렇게 함으로써 애플리케이션은 데이터를 디스크로 직접 복사하지 않고도 쓰기 작업을 수행할 수 있습니다. Zero-copy를 사용하면 데이터가 메모리에서 다른 장치나 프로세스로 복사되는 횟수를 줄일 수 있으므로 성능이 향상됩니다. 예를 들어, 네트워크에서 데이터를 수신하고 이를 처리하는 경우, Zero-copy를 사용하면 수신된 데이터를 메모리에서 직접 처리할 수 있으므로 복사 작업이 필요하지 않습니다.

### 주의사항

데이터를 공유하면서 동기화 문제가 발생할 수 있으며, 데이터 무결성을 보장하기 위해 추가적인 조치가 필요할 수 있습니다. 또한, Zero-copy를 사용할 수 없는 상황이나 환경도 있을 수 있으므로 적절한 상황에서 사용해야 합니다.


### 장점

- 성능 향상: Zero-copy를 통해 데이터 복사에 따른 오버헤드가 줄어들어 데이터 처리 속도가 향상되며, CPU 및 메모리 사용량도 감소합니다.
- 메모리 절약: 불필요한 데이터 복사를 피하므로 데이터 처리에 필요한 메모리 양이 줄어듭니다.
- 자원 효율성: Zero-copy는 CPU 캐시와 메모리 대역폭 등 하드웨어 자원을 효율적으로 활용할 수 있습니다.
- 지연 시간 감소: Zero-copy는 서로 다른 컴포넌트나 프로세스 간 데이터 전송 시간을 단축하여 데이터 집약적인 작업에서의 지연 시간을 줄일 수 있습니다.

### 사용용도

- 네트워크 프로그래밍: Zero-copy는 네트워크 인터페이스, 소켓 버퍼, 애플리케이션 버퍼 간 데이터 전송을 최적화하는 데 널리 사용됩니다.
- 파일 시스템: Zero-copy 기법은 파일 시스템에서 읽기 및 쓰기 작업을 개선하여 디스크 데이터에 빠르게 액세스할 수 있도록 합니다.
- 멀티미디어 처리: Zero-copy는 비디오나 오디오 스트림과 같은 대량 데이터를 효율적으로 처리해야 하는 멀티미디어 응용 프로그램에서 특히 유용합니다.

### Zero-copy 구현 기법

- 메모리 매핑: 메모리 매핑은 파일이나 다른 데이터 원본을 메모리에서 직접 액세스할 수 있게 해줌으로써 복사 과정이 필요하지 않게 합니다. C/C++과 같은 언어에서는 주로 mmap() 함수를 사용하여 메모리 매핑을 구현합니다.
- 직접 메모리 접근 (DMA): DMA는 네트워크 어댑터나 스토리지 컨트롤러와 같은 장치가 CPU를 우회하여 직접 메모리로 데이터를 전송할 수 있는 기능입니다. 이 기법을 사용하면 불필요한 복사가 제거되고 데이터 전송 작업에서 CPU의 참여가 줄어듭니다.
- 공유 메모리: 공유 메모리는 여러 프로세스가 동시에 동일한 메모리 영역에 액세스할 수 있는 메커니즘입니다. 메모리를 공유함으로써 프로세스 간에 복사 없이 데이터를 교환할 수 있습니다.

### 고려 사항 및 제한 사항

- 동기화: 여러 프로세스나 스레드가 공유 메모리에 동시에 접근하는 경우, 데이터 무결성을 보장하고 경쟁 조건을 방지하기 위해 적절한 동기화 메커니즘이 필요합니다.
- 데이터 정렬과 패딩: Zero-copy 기법을 사용할 때 데이터 정렬과 패딩 요구 사항을 고려해야 최적의 성능을 얻을 수 있습니다.
- 플랫폼 및 언어 지원: Zero-copy 기능은 플랫폼, 운영 체제 및 사용하는 프로그래밍 언어에 따라 다를 수 있습니다. 작업하는 구체적인 환경에서 제공되는 문서와 기능을 확인하는 것이 중요합니다.

### Example Code

```kotlin
import java.io.FileInputStream
import java.nio.channels.FileChannel

fun main() {
    val filePath = "path/to/file.txt"

    // 파일을 읽기 위해 FileInputStream을 생성하고 FileChannel을 얻음
    val fileInputStream = FileInputStream(filePath)
    val fileChannel = fileInputStream.channel

    // 파일의 크기를 얻어 ByteBuffer를 할당
    val fileSize = fileChannel.size()
    val buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileSize)

    // ByteBuffer를 처리
    processBuffer(buffer)

    // 사용이 끝난 리소스 해제
    fileChannel.close()
    fileInputStream.close()
}

fun processBuffer(buffer: java.nio.ByteBuffer) {
    // ByteBuffer의 데이터를 직접 읽어와 처리
    val data = ByteArray(buffer.remaining())
    buffer.get(data)

    // 데이터 처리 로직
    val processedData = processData(data)
    println(String(processedData))
}

fun processData(data: ByteArray): ByteArray {
    // 데이터 처리 로직 구현
    // 여기서는 데이터를 그대로 반환
    return data
}
```
